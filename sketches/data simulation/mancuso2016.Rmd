---
title: "mancuso2016"
author: "A Solomon Kurz"
date: "`r format(Sys.Date())`"
output: github_document
---

```{r, echo = F}
knitr::opts_chunk$set(fig.retina = 2.5)
options(width = 110)
```

The purpose of this file is to simulate the data from Mancuso & Miltenberger (2016; https://doi.org/10.1002/jaba.267). We don't have their actual data file, they displayed their data in Figure 1 (p. 191). Here we'll work through that figure to make a data file that approximates their original data.

Load the **tidyverse** and **juicr**.

```{r, warning = F, message = F}
library(tidyverse)
library(juicr)
```

First use the `juicr::GUI_juicr()` function to digitize the data, one participant at a time, from Figure 1 in Mancuso & Miltenberger (p. 191).

```{r, eval = F}
GUI_juicr("pics/rate01.png")
GUI_juicr("pics/rate02.png")
GUI_juicr("pics/rate03.png")
GUI_juicr("pics/rate04.png")
GUI_juicr("pics/rate05.png")
GUI_juicr("pics/rate06.png")
```

Now we combine the data in the .csv files, round the `session` values to integers, round the `rate` values to the third decimal place, and add participant identifiers.

```{r, warning = F, message = F}
d <- tibble(files = list.files(pattern = "rate0[1-6]*_juicr_extracted_points")) %>% 
  mutate(data = map(files, read_csv)) %>% 
  unnest(data) %>% 
  transmute(sn      = str_extract(files, "\\d+") %>% as.double(),
            session = round(x.calibrated, digits = 0),
            rate    = round(y.calibrated, digits = 3)) %>% 
  mutate(session0 = session - 1) %>% 
  arrange(sn, session) %>% 
  mutate(id = case_when(
    sn == 1 ~ "Jen",
    sn == 2 ~ "Anne",
    sn == 3 ~ "Kate",
    sn == 4 ~ "Laura",
    sn == 5 ~ "Sam",
    sn == 6 ~ "Amy"
  )) %>% 
  # convert id to an ordered factor
  mutate(id = fct_reorder(id, sn)) %>% 
  mutate(id = fct_rev(id))

# what?
head(d)
```

We need to manually add a `phase` variable, which will vary across participants and over time. I'm not aware of an elegant way to do this, so we'll just use brute force.

```{r}
d <- d %>% 
  mutate(phase = c(rep(letters[1:3], times = c(8, 5, 1)),
                   rep(letters[1:3], times = c(7, 11, 1)),
                   rep(letters[1:3], times = c(5, 6, 1)),
                   rep(letters[1:3], times = c(5, 5, 1)),
                   rep(letters[1:3], times = c(4, 7, 1)),
                   rep(letters[1:3], times = c(3, 5, 1))))
```

Here the `phase == "a"` is the baseline period, `phase == "b"` is the post-intervention assessment period, and `phase == "c"` is the follow-up.

Though the dependent variable was displayed as a rate in Figure 1, the underlying data were behavioral counts divided by the time periods in which they were measured. The difficulty is the authors did not report the actual durations of each student's speach, other than the general statement:

> All sessions included 3- to 5-min speeches. (p. 189)

A little further, we read:

> The researcher did not provide any guidelines for the speech outline. Each participant was allowed to use her outline during her speech. At 4 min into the speech, the researcher signaled that the participant had 1 min left to speak, and when 5 min had elapsed, the researcher signaled the end of the speech. If the participant attempted to end the speech before 3 min had elapsed or stopped speaking for more than 15 s, the researcher said, "please continue." Speeches ended when 5 min had elapsed or when at least 3 min had elapsed and the participant ended the speech. (pp. 189--190)

Here we'll use modified beta distributions to simulate the speech durations. $\operatorname{Beta}(0.5, 0.7)$ will make for speech durations slightly biased toward the lower limit and $\operatorname{Beta}(0.5, 0.7)$ will make for speech durations slightly biased toward the upper limit. Here are what those modified beta densities look like in a plot.

```{r, fig.width = 5, fig.height = 2.75}
tibble(x = c(seq(from = 0.001, to = 0.999, by = 0.001),
             seq(from = 0.001, to = 0.999, by = 0.001))) %>% 
  mutate(phase = rep(c("baseline", "post baseline"), each = n() / 2)) %>% 
  mutate(d = ifelse(phase == "baseline",
                    dbeta(x = x, shape1 = 0.5, shape2 = 0.7),
                    dbeta(x = x, shape1 = 0.7, shape2 = 0.5))) %>% 
  mutate(seconds = x * 120 + 180) %>% 
  
  ggplot(aes(x = seconds, y = d)) +
  geom_area() +
  coord_cartesian(ylim = c(0, 8)) +
  facet_wrap(~ phase)
```

Simulate and save.

```{r}
set.seed(1)

d <- d %>% 
  mutate(beta = ifelse(phase == "a", 
                       rbeta(n = n(), shape1 = 0.5, shape2 = 0.7),
                       rbeta(n = n(), shape1 = 0.7, shape2 = 0.5))) %>% 
  mutate(seconds = round(beta * 120 + 180, digits = 0)) %>% 
  mutate(minutes = seconds / 60) %>% 
  # compute the counts
  mutate(count = round(rate * (seconds / 60), digits = 0))
```

Now rearrange the columns in the `d` data and save the results as `mancuso2016`.

```{r}
mancuso2016 <- d %>% 
  select(sn, id, session, session0, phase, count, seconds, minutes, rate)

# what is this?
head(mancuso2016)
```

We can now make a version of Figure 1 from the paper.

```{r, fig.width = 5, fig.height = 6}
mancuso2016 %>% 
  mutate(phase = factor(phase,
                        labels = c("baseline", "postintervention", "follow-up"))) %>% 
  ggplot(aes(x = session, y = rate, color = phase, shape = phase)) +
  geom_point() +
  geom_line() +
  scale_color_manual(NULL, values = c("red3", "blue3", "green4")) +
  scale_shape_manual(values = c(16, 16, 15), breaks = NULL) +
  scale_y_continuous("rate", limits = c(0, NA), expand = expansion(mult = c(0.05, 0.25))) +
  facet_wrap(~ id, scales = "free_y", ncol = 1)
```

## Save

Now save the results in an external file.

```{r, eval = F}
save(mancuso2016, file = "/Users/solomonkurz/Dropbox/Experimental-design-and-the-GLMM/sketches/data/mancuso2016.rda")
```

## Session information

```{r}
sessionInfo()
```

